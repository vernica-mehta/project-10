Uploaded what I had done since we are getting very close to submission so Vernica can use it. 

# Diagnostic testing EOS 

Trying to figure out what is going on with EOS 
```python
print(f"Testing Saha output at T={T}K:")
print(f" ns[0] (should be H): {ns[0]:.3e}")
print(f" ns[1] (should be H+): {ns[1]:.3e}")
print(f" ns[2] (should be H-): {ns[2]:.3e}")
print(f" Charge check: n_e - n_H+ + n_H- = {n_e - ns[1] + ns[2]:.3e}")

```

Was finding charges were way off. 

Output: 
![[Pasted image 20251005220935.png]]


Took Mikes advice from the original discussion and made the problem smaller to just include just hydrogen in chemical equilibrium: 

For the $\ce{H <=> H2}$

I started with following mikes eos code: 
and loading in tsuji data: 

```python 
''''

This is me trying to walk through how eos.py works for a simple case of Hydrogen

To be used for presentation since I have had trouble if the Regular EOS to get it to work with molecules.

  

'''

  

import numpy as np

import matplotlib.pyplot as plt

import astropy.constants as c

import astropy.units as u

import scipy.optimize as op

from scipy.integrate import solve_ivp

from scipy.interpolate import interp1d

import astropy.io.fits as pyfits

from astropy.table import Table

  
  

# Reading in Equilibrium coeffiencents from Tsuji_K

tsuji_K = Table.read('/Users/griffinkatrivesisbrown/Library/Mobile Documents/iCloud~md~obsidian/Documents/project-10/grey_model/data/tsuji_K.dat', format='ascii.fixed_width_no_header', \

names=('mol', 'c0', 'c1', 'c2','c3','c4','molcode','ediss','comment'), col_starts=(0,7,19,31,43,55,67,80,87))

```

Our constants and composition of only Hydrogen
```python
# Constants from eos.py

debroglie_const = (c.h**2/2/np.pi/c.m_e/c.k_B).cgs.value

eV_Boltzmann_const = (u.eV/c.k_B).cgs.value

deybe_const = (c.k_B/8/np.pi/c.e.esu**2).cgs.value

delchi_const = (c.e.esu**2/(1*u.eV)).cgs.value

  

# I simplified the compostion function to work with just H

  

def composition():

"""Return hydrogen properties only"""

elt_names = np.array(['H'])

n_p = np.array([1])

masses = np.array([1.0])

abund = np.array([1.0]) # 100% H

ionI = np.array([13.595])

ionII = np.array([-0.754]) # H- (negative ion)

gI = np.array([2])

gII = np.array([1])

gIII = np.array([1])

return abund, masses, n_p, ionI, ionII, gI, gII, gIII, elt_names

  

# Now we need to create a saha equation first as this will give us an idea of how many elements are ionised
```

# Saha 

```python 
"""

  

Currently Ignoring all Molecules expect H2

  

"""

  
  

def saha_h2_only(n_e, T):

"""

Full Saha equation solver for H only taken from eos.saha,

Solves matrix system for just H, H+, H- number densities

Includes Debye screening and proper matrix formulation

Debye screening -> Tells us how electric fields weakened in a plasma or ionized gas

due to the collective response of free charged particles.

  

This enables the problem to be a simple Ax=b linear problem.

Results from this function can be used to solve the Saha equation as e.g. a function

of rho and T via e.g. tabulating or solving.

  

Parameters

----------

n_e: double

the electron number density in cm^{-3}

T: double

Temperature in K.

Returns

-------

rho: astropy.units quantity compatible with density

mu: Mean molecular weight (dimensionless, i.e. to be multiplied by the AMU)

ns: A vector of number densities of H, H+, H-, in cm^{-3}

"""

# loads in our composition

abund, masses, n_p, ionI, ionII, gI, gII, gIII, elt_names = composition()

n_elt = len(n_p) # Just 1 for H

# Debye screening

#according to Mihalas 9-178

deybe_length = np.sqrt(deybe_const*T/n_e)

z1_delchi = delchi_const/deybe_length

# Low temperature case

# Ionisation fraction to zero

if T < 2000:

ns = np.zeros(n_elt * 3)

ns[3*np.arange(n_elt)] = abund # Neutral atoms

ns = np.maximum(n_e * 1e15 * ns, 1e-300)

else:

# Thermal de Broglie wavelength

debroglie = np.sqrt(debroglie_const / T)

# Construct matrix

A = np.zeros((3*n_elt, 3*n_elt));

for i in range(n_elt):

# First equation: abundance ratio

# Sum of all H states / Sum of all H states = abund[i]/abund[0]

#densities to H number densities is the ratio of abundances.

A[3*i, 3*i:3*(i+1)] = [-abund[0], -abund[0], -abund[0]]

A[3*i, :3] = [abund[i], abund[i], abund[i]]

  

# Single ionization equilibrium for element

he1 = 2./debroglie**3 *gII[i]/gI[i]*np.exp(-(ionI[i] - n_p[i]*z1_delchi)*eV_Boltzmann_const/T)

A[3*i+1, 3*i:3*i+2] = [-he1/n_e, 1] # -K/n_e * n_neutral + n_ion = 0

# H- formation (special case for i=0)

if i == 0:

he2 = 2. / debroglie**3 * gI[i] / gIII[i] * np.exp(-(np.abs(ionII[i]) - n_p[i]*z1_delchi) * eV_Boltzmann_const / T)

A[3*i+2, 3*i:3*i+3] = [1, 0, -he2/n_e] # n_neutral - K/n_e * n_Hminus = 0

else:

# Double ionization (not relevant for H only, but keeping structure)

he2 = 2. / debroglie**3 * gIII[i] / gII[i] * np.exp(-(ionII[i] - n_p[i]*z1_delchi) * eV_Boltzmann_const / T)

A[3*i+2, 3*i+1:3*i+3] = [-he2/n_e, 1]

  

#Add in the equation for electron number density. This over-writes the equation

#n_H + n_H

A[0, :] = np.concatenate(([0, 1, -1], np.tile([0, 1, 2], n_elt-1)))

#where b only has one non-zero number (the electron

#number density)

b = np.zeros(3*n_elt)

b[0] = n_e

ns = np.linalg.solve(A, b)

# Make sure all densities are postive

ns = np.maximum(ns, 1e-300)

# High temperature/pressure ionization correction

ns_highT = np.zeros(n_elt * 3)

ns_highT[1] = abund[0] # Fully ionized H

ns_highT[2 + np.arange(n_elt-1)*3] = abund[1:] # Other elements ionized

ns_highT = ns_highT / (abund[0] + 2*np.sum(abund[1:])) * n_e

atom_size = 1e-8 # cm

if n_e * atom_size**3 > 2:

ns = ns_highT

elif n_e * atom_size**3 > 1:

frac = (n_e * atom_size**3 - 1) / 1.0

ns = frac * ns_highT + (1 - frac) * ns

# Calculate total H 

n_h = np.sum(ns[:3])

# Density

rho_in_g_cm3 = n_h * np.sum(abund * masses) * c.u.to(u.g).value

#Fractional "abundance" of electrons.

f_e = n_e / n_h

# Mean molecular weight

mu = np.sum(abund * masses) / (np.sum(abund) + f_e)

# Specific internal energy: ionization energy per unit mass

# Normalized per H nucleus (reference unit) but accounting for

# the mean molecular weight of the full gas mixture

Ui = (ns[1] * 13.6) * u.eV / n_h / np.sum(abund * masses * u.u)

return rho_in_g_cm3, mu, Ui, ns
```

Our saha solver from eos.saha_solve 
```python 

def saha_solve_h2(log_n_e_mol_cm3, T_K, rho_0_in_g_cm3):
"""

Find the value of n_e (electron density) that produces the correct total mass density

(taken from eos.saha_solve)

"""

n_e = np.exp(log_n_e_mol_cm3) * c.N_A.value

rho, mu, Ui, ns = saha_h2_only(n_e, T_K)

return np.log(rho_0_in_g_cm3 / rho)
```

Initially I was having errors:
![[Pasted image 20251010081913.png]]

Through some fun print functions I found that the error came from me not adding a index and so python got confused when calculating in the saha equation like above. 

So went from:
np.exp(log_n_e_mol_cm3)
To:
np.exp(log_n_e_mol_cm3[0])



Then we have take from mikes code and modified slighty to work with just hydrogen like the rest of the functions 
```python 
def ns_from_rho_T_h2(rho, T):

"""

Compute ionization state from density and temperature (like eos.ns_from_rho_T)

Uses full Saha equation to get H, H+, H- abundances ignoring molecules.

"""

rho_in_g_cm3 = rho.to(u.g/u.cm**3).value

  

# Initial guess for electron density

x0 = np.log(rho_in_g_cm3)

T_K = np.maximum(T.to(u.K).value,1000)

x0 += np.log(2/(10*np.exp(40e3/T_K) + 1))

# Solve for n_e that gives correct density

print(T.cgs.value)

res = op.fsolve(saha_solve_h2, x0, args=(T.cgs.value, rho_in_g_cm3), xtol=1e-6)

n_e = np.exp(res[0]) * c.N_A.value

# Get final results from full Saha equation

rho_check, mu, Ui, ns = saha_h2_only(n_e, T.cgs.value)

# Verify convergence

print(T_K)

print(T.cgs.value)

if np.abs(rho_check / rho_in_g_cm3 - 1) > 0.01:

print(f"Warning: Density check failed ({rho_check:.3e} vs {rho_in_g_cm3:.3e})")


return n_e*(u.cm**(-3)), ns*(u.cm**(-3)), mu, Ui
```









