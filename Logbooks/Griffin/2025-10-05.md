
Sent email to mike: asking for help on the saha equation on errors we were still getting. 

Now when it came to dealing with molecules we first start off with our equilibrium_equation which follows a similar path to mikes OG code but again slight changes and notes for only using hydrogen

```python 
"""

Dealing with molecules

  

"""

  

def equilibrium_equation_h2_only(rho, T):

"""

Simplified version of eos.equilibrium_equation() for H2 only.

Returns the components needed to solve

"""

abund, masses, n_p, ionI, ionII, gI, gII, gIII, elt_names = composition()

# Reference pressure,which is the ideal gas pressure corresponding to

#atomic Hydrogen only.

log_P_ref = np.log10((rho * c.k_B * T / u.u).to(u.dyn/u.cm**2).value)

# Get H2 data

nmol = 1 # we only have one molecule

natom = len(abund)

  

'''

In original it was:

The linear matrix, with one equation (row) per atom, one

for the electron.

Species ordering: [e-, neutrals (natom), ions (natom), molecules (nmol)]

For us we now only need to worry about H so:

'''

# For H only: [e-, H, H+, H2]

# Total columns = 1 + 2*natom + nmol = 1 + 2*1 + 1 = 4

# Linear matrix (conservation equations)

# Rows: 1 (electron) + natom (atom conservation) = 1 + 1 = 2

linear_matrix = np.zeros((natom+1, 1 + 2*natom + nmol))

linear_b = np.zeros((natom + 1))

  
  

# Logarithmic matrix (equilibrium equations)

# Rows: natom (ionization) + nmol (molecules) = 1 + 1 = 2

log_matrix = np.zeros((natom + nmol, 1 + 2*natom + nmol))

log_b = np.zeros(natom + nmol)

  

#The theta value for computing the molecular equilibrium constants

theta = 5040/T.to(u.K).value

#The equivalent for the atoms

eV_kTln10 = float(1*u.eV/c.k_B/T/np.log(10))

  

#First, the electron equation

# All ions contribute: -P_e + sum(P_ions) = 0

linear_matrix[0,1+natom:1+2*natom] = 1 # Original would be all ions but for single H is just H+

linear_matrix[0,0] = -1 # Negative electron pressure

  

#Next, the RHS of the equation

linear_b[1:] = abund/np.sum(masses*abund)

  

#Prod in = Prod loss

# Total H atoms (in) = Total H atoms (out)

# Now, the atomic part of the equation

for i in range(natom):

linear_matrix[i+1, i+1] = 1 # Neutral atom

linear_matrix[i+1, natom+i+1] = 1 # Ion

  

  

debroglie = np.sqrt(debroglie_const / T.to(u.K).value)

kBT = (c.k_B * T).cgs.value

#The logarithmic part of the matrix for atoms.

for i in range(natom):

log_b[i] = np.log10(2*kBT/debroglie**3 *gII[i]/gI[i]) - eV_kTln10*ionI[i]

log_matrix[i,0] = 1

log_matrix[i,1+i] = -1

log_matrix[i,1+i+natom] = 1

  

#Next, the molecular part of the equation

for i in range(nmol):

log_matrix[natom + i, 2*natom+1+i] = -1 # -log(P_molecule)

  

# This is not very useful in this case since we are only dealing with one molecule, mol = HH

# If there was more molecules it would go through each one

mol = tsuji_K[i]

# Applying chemical equilibrium coeffiencents from Tsuji_K

log_b[natom + i] = mol['c0'] + mol['c1']*theta + mol['c2']*theta**2 + mol['c3']*theta**3 + mol['c4']*theta**4

  

molcode = mol['molcode']

n_element_types = int(molcode[0]) # Number of different elements in molecule

  

for j in range(n_element_types):

atom = int(molcode[1+j*3:3+j*3])

natom_in_mol = int(molcode[3+j*3:4+j*3])

k = np.argwhere(n_p==atom)[0,0]

linear_matrix[k+1,2*natom+1+i] = natom_in_mol

log_matrix[natom + i, 1+k] = natom_in_mol

return linear_matrix, linear_b, log_matrix, log_b, log_P_ref
```

Used mikes code for: 
```python 
ef eq_solve_func_h2(logps, linear_matrix, linear_b, log_matrix, log_b, log_P_ref, abund):

"""

Simplified version of eos.eq_solve_func()

Combines logarithmic equilibrium equations with linear conservation equations.

  

Returns:

--------

resid: np.array

concatenated log resids (n_atoms + n_mol) then concatenated linear resids

(1 + n_atoms)

"""

ps = 10**(logps - log_P_ref)

# Logarithmic part (equilibrium)

log_part = np.dot(log_matrix, logps) - log_b

# Linear part (conservation)

linear_part = np.dot(linear_matrix, ps) - linear_b

#Dividing the linear part by the abundance just makes all numbers near 0 and the

#same order of magnitude.

linear_part[1:] /= abund # Normalize

return np.concatenate((log_part, linear_part))
```

Then I simplified mikes version of equilibrium solve, The most notable parts is choices in how much H , $\ce{H2}$ and H+ and H-

I decided to have H in mostly a neutral state because that is what would be typical at these lower temps then I need to factor in the fact that H would be mostly $\ce{H2}$ below around 2000K also add in little H2 at high temps. 

```python 
# Start with mostly neutral H

x0[1] = log_P_ref # H (neutral)

x0[0] = log_P_ref - 6 # e- (low)

x0[2] = log_P_ref - 6 # H+ (low)

# H2 depends on temperature

if T.to(u.K).value < 2000:

x0[3] = log_P_ref - 0.5 # Mostly H2 at low T

x0[1] -= 2 # Less atomic H

else:

x0[3] = log_P_ref - 5 # Little H2 at high T
```

This formed: 

```python 
def equilibrium_solve_h2(rho, T):

"""

Simplified version of eos.equilibrium_solve()

Solves for equilibrium of H, H+, e-, and H2 at given density and temperature.

Returns:

--------

log(pressure) in dyn/cm^2 for: [e-, H, H+, H2]

"""

linear_matrix, linear_b, log_matrix, log_b, log_P_ref = equilibrium_equation_h2_only(rho, T)

abund, masses, n_p, ionI, ionII, gI, gII, gIII, elt_names = composition()

#Starting point -> using saha equation to get our initial guess

n_e, ns, mu, Ui = ns_from_rho_T_h2(rho,T)

#Convert number density to log partial pressure.

if min(ns)<0:

import pdb; pdb.set_trace()

logp_atom = np.log10((ns*c.k_B*T).to(u.dyn/u.cm**2).value)

logpe = np.log10((n_e*c.k_B*T).to(u.dyn/u.cm**2).value)

x0 = np.ones(linear_matrix.shape[1])*log_P_ref - 12

x0[0] = logpe #n_e

x0[1+np.arange(len(abund))] = logp_atom[3*np.arange(len(abund))] #neutrals

x0[len(abund)+1+np.arange(len(abund))] = logp_atom[3*np.arange(len(abund))+1] #ions

  

# Initial guess

#x0 = np.ones(linear_matrix.shape[1])*log_P_ref - 12

#x0[1:len(abund)+1] = log_P_ref + np.log10(abund)

  

# Start with mostly neutral H

x0[1] = log_P_ref # H (neutral)

x0[0] = log_P_ref - 6 # e- (low)

x0[2] = log_P_ref - 6 # H+ (low)

# H2 depends on temperature

if T.to(u.K).value < 3000:

x0[3] = log_P_ref - 0.5 # Mostly H2 at low T

x0[1] -= 2 # Less atomic H

else:

x0[3] = log_P_ref - 5 # Little H2 at high T

res = op.root(eq_solve_func_h2, x0,

args=(linear_matrix, linear_b, log_matrix, log_b, log_P_ref, abund),

method='lm')

if res.success:

return res.x

else:

print("WARNING: Solution did not converge")

return res.x
```

 My biggest approximation came in the form of getting the pressure, we choose not to include gamma, mu , Ui or ne as using the pressures from equilibrium_solve_h2 should give us a pretty goof idea of the behaviour. 
```python 
def eos_rho_T_h2_only(rho, T):

"""

Big approximation because dealing the saha equation is a pain:

doesn't include gamma, mu , Ui or ne

Returns:

--------

P: Total pressure

species_pressures: Dictionary with partial pressures

"""

# Solve equilibrium

logps = equilibrium_solve_h2(rho, T)

# Convert to pressures

ps = 10**logps * u.dyn / u.cm**2

species_pressures = {

'e-': ps[0],

'H': ps[1],

'H+': ps[2],

'H2': ps[3]

}

# Total pressure

P_total = np.sum(ps)

return P_total, species_pressures
```


We then plotted the results: 

![/Users/griffinkatrivesisbrown/Library/Mobile Documents/iCloud~md~obsidian/Documents/project-10/grey_model/EoS/h2_eos_simple.png](file:///Users/griffinkatrivesisbrown/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/project-10/grey_model/EoS/h2_eos_simple.png)

These seem to agree with **Taylor J. Bell 2018** results 





Working through this 
I found the Original problem in the eos.py was I was just reading in the Saha equation without the molecules so it was the exact same as what we originally had. 

Then the next difficulty was the fact that at lower temperatures the saha equation failed and spat out really low number because there was no ionisation makes sense. 

I spent the rest of the day trying to implement more molecules into our equation of state that could then be used in opac.py. 

Started by setting up a new eos.py file that follows a similar structure to the more simpler eos file I made for just H. 

Kept my composition function:
```python 
composition()

"""
Including now Major chemical species of CH4 and NH3 as well as H2

"""

```

used a very similar:
```python 
saha(n_e, T)
saha_solve(log_n_e_mol_cm3, T, rho_0_in_g_cm3)
eq_solve_func(logps, linear_matrix, linear_b, log_matrix, log_b, log_P_ref, abund)
ns_from_rho_T(rho,T)
```

Functions 

When it came to chemical equilbrium
```python 
equilibrium_equation(rho, T)
eq_solve_func(logps, linear_matrix, linear_b, log_matrix, log_b, log_P_ref, abund):
```
Stayed pretty much the same

In: 
```python 

equilibrium_solve(rho, T, plot=False)
"""
Changed the starting conditions to work with my molecules
This:
"""

#Deplete H, C, O, N, Ti just a little to stop the algorithm getting stuck.

x0[1] -= 0.4

x0[3] -= 0.2

x0[4] -= 0.2

x0[5] -= 0.4

x0[14] -= 0.3

#Also start the most abundant molecules as 0.5 dex less than their limiting constituent

x0[-4] = x0[1]-0.5

x0[-3] = x0[3]-0.5

x0[-2] = x0[5]-0.5

x0[-1] = x0[5]-0.5


"""
Became:
"""


# Start with mostly neutral H

x0[1] = log_P_ref # H (neutral)

x0[0] = log_P_ref - 6 # e- (low)

x0[2] = log_P_ref - 6 # H+ (low)

# H2 depends on temperature

if T.to(u.K).value < 2000:

x0[-3] = log_P_ref - 0.5 # Mostly H2 at low T

x0[1] -= 2 # Less atomic H

else:

x0[3] = log_P_ref - 5 # Little H2 at high T


```

As a starting point 


```python
x0[1] -= 0.4 # H (neutral)

x0[3] -= 0.2 # C

x0[4] -= 0.2 # N

x0[0] = log_P_ref - 6 # e- (low)

x0[6] = log_P_ref - 6 # H+ (low) (should do molecules first )


# added in from eos as there are more molecules 
x0[11] = x0[1]-0.5

x0[12] = x0[3]-0.5

x0[13] = x0[4]-0.5

  

# H2 depends on temperature

if T.to(u.K).value < 3000:

x0[11] = log_P_ref - 0.5 # Mostly H2 at low T. tsuji_K[‘mol’][0]

x0[1] -= 2 # Less atomic H

else:

x0[3] = log_P_ref - 5 # Little H2 at high T



```









Needed a way to add equilbrium solve into P_T_tables(Ps, Ts, savefile='')
which is dependent on:

ns_from_P_T(Ps[0], Ts[0])

- dependant on saha_solve_P(log_n_e_mol_cm3, P_0_cgs, T)

equilbrium solve is also dependent on: 
ns_from_rho_T

Adding this into both ns_from_rho_T and ns_from_P_T to allow them to work with and without molecules it also need to restructured to fit the saha density config: 

```python 
if use_molecules == True:

try:

# Use full chemical equilibrium solver

logPs = equilibrium_solve(rho, T, plot=False)

# logPs structure: [e-, neutrals(5), ions(5), molecules(3), H-]

# We need to reconstruct ns in Saha format: [H, H+, H-, He, He+, He++, ...]

abund, masses, _, _, _, _, _, _, _ = composition()

n_elt = len(abund)

# Extract pressures and convert to densities

Ps = (10**logPs * u.dyn/u.cm**2)

n_e = (Ps[0] / c.k_B / T).to(u.cm**(-3))

# Reconstruct ns in the correct order

ns = np.zeros(3*n_elt) * u.cm**(-3)

for i in range(n_elt):

ns[3*i] = (Ps[1+i] / c.k_B / T).to(u.cm**(-3)) # Neutral

ns[3*i+1] = (Ps[1+n_elt+i] / c.k_B / T).to(u.cm**(-3)) # Singly ionized

if i == 0:

ns[2] = (Ps[-1] / c.k_B / T).to(u.cm**(-3)) # H- (last element)

else:

ns[3*i+2] = 1e-30 * u.cm**(-3) # Doubly ionized (negligible at low T)

# Compute mu and Ui from the distribution

n_h = np.sum(ns[:3])

f_e = n_e / n_h

mu = np.sum(abund*masses) / (np.sum(abund) + f_e)

Ui = ((ns[1]*13.6 + ns[4]*24.58 + ns[5]*(54.403+24.58)) * u.eV /

n_h / np.sum(abund*masses*u.u))

return n_e, ns, mu, Ui

```

Then loaded all in and I hit an errror in equilibrium solver:

```

result = super().__array_ufunc__(function, method, *arrays, **kwargs) <ipython-input-1-56dc878da750>:282: RuntimeWarning: divide by zero encountered in scalar divide debroglie=np.sqrt(debroglie_const/T.to(u.K).value) <ipython-input-1-56dc878da750>:285: RuntimeWarning: divide by zero encountered in log10 log_b[i] = np.log10(2*kBT/debroglie**3 *gII[i]/gI[i]) - eV_kTln10*ionI[i] <ipython-input-1-56dc878da750>:294: RuntimeWarning: invalid value encountered in scalar add log_b[natom + i] = mol['c0'] + mol['c1']*th + mol['c2']*th**2 + mol['c3']*th**3 + mol['c4']*th**4 <ipython-input-1-56dc878da750>:317: RuntimeWarning: overflow encountered in power ps = ( 10**(logps-log_P_ref) )

--Return-- None > <ipython-input-1-56dc878da750>(409)equilibrium_solve() 407 return np.concatenate( (res.x, [logp_atom[2]])) 408 else: --> 409 import pdb; pdb.set_trace() 410 411

```

