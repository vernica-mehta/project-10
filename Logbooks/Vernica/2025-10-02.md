# 2025-10-02

I have done a bunch of work today trying to incorporate molecular absorption lines to the grey model. While the code seems to work, it doesn't actually have an impact to the grey atmosphere since absorption lines are not visible in grey atmospheres, however, could be useful for a non-grey model.

## ExoMolHR

Used this web-based interface to download stick absorption spectra of methane, ammonia, and water. Set temperature to 144K to attempt to make work with default Jupiter conditions. 

## `molecular_lines.py`

Created this file to process downloaded csvs from ExoMolHR. Used similar methods to Mike's code to calculate molecular opacities and add to exisiting conditions from grey model. 

```python
	def compute_molecular_opacity(self, nu_grid, T, P, molecule_abundances, max_lines=100):

	total_opacity = np.zeros_like(nu_grid)
	
	for molecule, data in self.molecules.items():
		if molecule not in molecule_abundances:
			continue
	
	# Get line data
	line_freqs = (data['frequencies'] * c.c).to(u.Hz).value
	strengths = data['line_strengths']
	lower_energies = data['lower_energy']
	
	# Limit to strongest lines only
	n_total_lines = len(line_freqs)
	
	if n_total_lines > max_lines:
		sort_indices = np.argsort(strengths)[::-1][:max_lines]
		line_freqs = line_freqs[sort_indices]
		strengths = strengths[sort_indices]
		lower_energies = lower_energies[sort_indices]
	
	n_lines = len(line_freqs)
	
	# Pre-calculate constants
	number_density_val = molecule_abundances[molecule].value if hasattr(molecule_abundances[molecule], 'value') else molecule_abundances[molecule]
	molecular_mass = self.get_molecular_mass(molecule)
	
	# Pre-calculate Boltzmann factors for all lines
	kT_cgs = c.k_B.cgs.value * T / u.K # erg
	E_lower_erg = lower_energies.to_value(u.cm**-1) * c.h.cgs.value * c.c.cgs.value # erg
	boltzmann_factors = np.exp(-E_lower_erg / kT_cgs)
	
	for i in range(n_lines):
		nu0 = line_freqs[i]
		S = strengths[i]
		boltzmann = boltzmann_factors[i]
		
		# Line strength at temperature T
		line_strength_val = S * boltzmann
		if hasattr(line_strength_val, 'value'):
			line_strength_val = line_strength_val.value
		
		# Doppler width
		molecular_mass = self.get_molecular_mass(molecule)
		doppler_width = (nu0 * u.Hz * np.sqrt(c.k_B * T / molecular_mass) / c.c).to(u.Hz).value
		
		# Broadening (using arbitrary values)
		gamma_natural = 1e6
		gamma_pressure = P * 1e-3
		gamma_total = gamma_natural + gamma_pressure
		
		# Voigt profile
		x = (nu_grid - nu0) / doppler_width
		profile = voigt_profile(x, 1.0, gamma_total/doppler_width)
		profile = profile / (doppler_width * np.sqrt(2 * np.pi)) # Hz^-1
		
		# Calculate opacity contribution
		opacity_contribution = (number_density_val * line_strength_val * profile * 1e18)

		total_opacity += opacity_contribution
	
	return total_opacity
```

## Other code changes

- added `abundances.py` which contains a simple function defining a dictionary of water, methane, and ammonia abundances of Jupiter
- added `kappa_cont_molecules` function to `opac.py` which is a modified opacities function using the molecular calculations, can be called instead of `kappa_cont` if want to get spectrum with molecular opacities

In terms of usefulness, this code really just exists as an alternative branch to the non-grey model, i.e. instead of using picket-fence opacities this is more specific to actual molecules present in exoplanetary atmospheres. However, it is unlikely that there will be enough time to actually implement this into a full non-grey code before next week when this is due.

![figure](<Pasted image 20251003110233.png>)
