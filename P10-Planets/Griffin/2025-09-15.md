Still was struggling to find opacities at low temperatures probably due to the high bonds between electrons; so I am just making a note here of what I need to change in the code so I can copy and paste it in when I have the values. 

Functions I need:

From yesterday I need a crossection: 
 $$\sigma_{i,\nu}$$
And density: 
$$n_i$$
Density in theory if I understand it write is quite straight forward as in the saha_eos.py it creates densities and puts it into:
```python
ns = f_eos['ns [cm^-3]'].data
```

where comment in code is:
- ns: A vector of number densities of H, H+, H-, He, He+, He++ in cm^{-3} 
>[!note]
>Not to sure where Ne and CH4 and NH3 come in 
>Where:
>```python
>"""Return Jupiter's atmospheric composition, according to Opik (1962)"""
elt_names = np.array(['H', 'He', 'Ne', 'CH4', 'NH3'])
>```

Then this is put into base 10  log10ns: 
```python
number_of_elements = ns.shape[2]

log10ns = []

for i in range(number_of_elements):

# Create 2D interpolation function for particle i

# RectBivariateSpline expects (x, y, z) where z[i,j] = f(x[i], y[j])

interp_func = RectBivariateSpline(Ps_log10, Ts, np.log10(ns[:,:,i]))

log10ns.append(interp_func)

log10ne = RectBivariateSpline(Ps_log10, Ts, np.log10(ne_table))
```

So our densities would be: 
```python
nHeI = 10**(log10ns[3](log10P, T_val, grid=False)) #He 
nHeII = 10**(log10ns[4](log10P, T_val, grid=False)) #He+ 
nHeIII = 10**(log10ns[5](log10P, T_val, grid=False)) #He++
```

>[!note]
>Want to double check if He++ is suppost to be double ionised or He- since in [[@marigoUpdatedLowtemperatureGas2022]] only has He, He+ and He- 

The complex part comes from the cross sections this is due to need to me finding it difficult to find them.

For He we have Free–free and Bound–free
For He+ we have Free–free and Bound–free
For He- we have Free–free

we know from [[@marigoUpdatedLowtemperatureGas2022]]:
$\sigma_{ff}(He) = \sigma_{ff}(H) (assumed)$
$\sigma_{ff}(He+) = \sigma_{ff}(H) (assumed)$

Making:
```python 
HeIff = Hff(nu, T_val) 
HeIIff = Hff(nu, T_val) 
```

Then for $\ce{HeI}$ Bound Free from we have the following: 

![[Pasted image 20250916000826.png]]

From the above table: 
```python 
he_levels =[# Level 1: 1S 
[1,1,0.0,5.9447e15,[33.32,-2.0]],
# Level 2: 2^3S  
[3,3,19.819,1.1526e15,[-390.026,21.035,-0.318]],
# Level 3: 2^1S 
[1,1,20.615,0.96025e15,[26.83,-1.91]],
# Level 4: 2^3P^0 
[9,9,20.964,0.87607e15,[61.21,-2.9]],
# Level 5: 2^1P^0 
[3,3,21.217,0.81465e15,[81.35,-3.5]],
# Level 6: 3^3S 
[3,3,22.718,0.4519e15,[12.69,-1.54]],
# Level 7: 3^1S 
[1,1,22.920,0.4031e15,[23.85,-1.86]],
# Level 8: 3^3P^0 
[9,9,23.006,0.3821e15,[49.30,-2.60]],
# Level 9: 3^3D+3^1D 
[20,20,23.073,0.3659e15,[85.20,-3.69]],
# Level 11: 3^1P^0 
[3, 3, 23.086, 0.3628e15, [58.81, -2.89]]]
```

The beta function: 

```python 
def HeIbf(nu, T):

"""Compute the Helium bound-free cross sections in cgs units as a

function of temperature in K. Computed per atom. Computed using:

https://articles.adsabs.harvard.edu/pdf/1970SAOSR.309.....K

Parameters

----------

nu: Frequency or a list (numpy array) of frequencies.

"""

he_level =[# Level 1: 1S 

[1,1,0.0,5.9447e15,[33.32,-2.0]],

# Level 2: 2^3S  

[2,3,19.819,1.1526e15,[-390.026,21.035,-0.318]],

# Level 3: 2^1S 

[3,1,20.615,0.96025e15,[26.83,-1.91]],

# Level 4: 2^3P^0 

[4,9,20.964,0.87607e15,[61.21,-2.9]],

# Level 5: 2^1P^0 

[5,3,21.217,0.81465e15,[81.35,-3.5]],

# Level 6: 3^3S 

[6,3,22.718,0.4519e15,[12.69,-1.54]],

# Level 7: 3^1S 

[7,1,22.920,0.4031e15,[23.85,-1.86]],

# Level 8: 3^3P^0 

[8,9,23.006,0.3821e15,[49.30,-2.60]],

# Level 9: 3^3D+3^1D 

[9,20,23.073,0.3659e15,[85.20,-3.69]],

# Level 11: 3^1P^0 

[11, 3, 23.086, 0.3628e15, [58.81, -2.89]]]

  
  
  

nu_val = nu.to_value(u.Hz) if hasattr(nu, 'unit') else nu

T_val = T.to_value(u.K) if hasattr(T, 'unit') else T

alpha = np.zeros_like(nu_val)

ev_kB_cgs = (1*u.eV/c.k_B).cgs.value

  

for i in range(0,len(he_level)):

level = he_level[i][0]

g_i = he_level[i][1]

E_i_eV = he_level[i][2]

nu_threshold = he_level[i][3]

ln_a_i = he_level[i][4]

  

mask = nu_val >= nu_threshold

  

nu_masked = nu_val[mask]

  

if len(ln_a_i) == 2:

a = ln_a_i[0]

b = ln_a_i[1]

ln_a = a + b * np.log(nu_masked)

else:

a = ln_a_i[0]

b = ln_a_i[1]

c = ln_a_i[2]

ln_a = a + (b+c * np.log(nu_masked))*np.log(nu_masked)

  

# Note question for higher levels -> do I need to do n=> 4 differently

  

cross_section = np.exp(ln_a)

boltzmann_factor = g_i * np.exp(-E_i_eV * ev_kB_cgs / T_val)

# total crossection

alpha[mask] += cross_section * boltzmann_factor

return alpha * (1-np.exp(-h_kB_cgs*nu_val/T_val))
```

![[Pasted image 20250916020225.png]]

Function coming soon :) 
```python 
def HeIIbf()

```

Stopped here cause have questions around g_i to. 

>[!note]
>Not to sure what to do with the strong line and weak line functions and for now I am going to wait till class to do either He- or He++ as I am not to sure what one. 

This creates a function: 
```python 
def kappa_cont(nu, log10P, T):

"""Compute the continuum opacity in cgs units as a function of

log pressure (CGS) and K.

Parameters:

nu: numpy array

log10P: float

T: float

"""

T_val = T.to_value(u.K) if hasattr(T, 'unit') else T

nHI = 10**(log10ns[0](log10P, T_val, grid=False))

nHII = 10**(log10ns[1](log10P, T_val, grid=False))

nHm = 10**(log10ns[2](log10P, T_val, grid=False))


# For Helimn 
nHeI = 10**(log10ns[3](log10P, T_val, grid=False)) #He 
nHeII = 10**(log10ns[4](log10P, T_val, grid=False)) #He+ 
nHeIII = 10**(log10ns[5](log10P, T_val, grid=False)) #He++

HeIff = Hff(nu, T_val) 
HeIIff = Hff(nu, T_val) 

# Electron 


ne = 10**(log10ne(log10P, T_val, grid=False))





kappa = nHI * Hbf(nu, T_val) + nHII * ne * Hff(nu, T_val) + \

nHm * Hmbf(nu, T_val) + nHI * ne * Hmff(nu, T_val) + \

nHeI*Hebf(nu, T_val) + nHeII*Hebf(nu, T_val) + \
nHeI*HeIff(nu, T_val) + nHeII*HeIIff +
...??? # need to add either He++ or He- ?? 

return kappa
```

